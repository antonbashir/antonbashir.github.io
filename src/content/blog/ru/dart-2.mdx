---
title: "О времени, сложности и мотивации: такие разные функции в Dart"
description: Мои приключения в мире Dart VM. Часть 2. 
date: "2025-04-11"
label: Article
tags: IT, Dart, Dart VM, ASM, Coroutines, Habr
time: 20 min
---
> [!NOTE]
>Приветствую вас, читатели. Для начала я рекомендую вам ознакомиться с [первой частью](/blog/ru/dart-1) моего цикла статей.
>В этом цикле я пишу о балансе, состояниях разработчика, корутинах и Dart.
>Все части:
>* [Часть 1: О времени, сложности и мотивации: знакомство](/blog/ru/dart-1)
>* [Часть 2: О времени, сложности и мотивации: такие разные функции в Dart](/blog/ru/dart-2)
>* [Часть 3: О времени, сложности и мотивации: история поражения](/blog/ru/dart-3)
>* [Часть 4: О времени, сложности и мотивации: история победы](/blog/ru/dart-4)
>* [Часть 5: О времени, сложности и мотивации: финал](/blog/ru/dart-5)

# Об авторе

Меня зовут Антон, и я — чайный программист-даос.
Я 10 лет пишу код на разных языках, увлекаюсь даосизмом, китайским чаем и созданием никому не нужных (кроме меня) велосипедов. 
Чуть подробнее обо мне [тут](/blog/ru/dart-1) 

# Поговорим про понятия

Итак, с чем мы работаем ?
* Thread 
* Isolate
* Future
* Coroutine & Fiber

Я постараюсь дать мои собственные определения этим понятиям с учетом работы с Dart.

## Thread

Поток, нить - так его называют. Концепция потока присутствует во многих языках, с которыми я работал.

> [!NOTE]
> А вот в Dart её нет. Точнее, её нет для Dart разработчика, но в Dart VM с потоками все хорошо.

Всегда эта концепция представляет собой что-то, что нужно использовать для параллельного выполнения кода.

Я раскрываю эту концепцию таким образом: поток - это структура, содержащая стек, хранилище, атрибуты, состояние и что-то еще в зависимости от реализации.

Управляет этой структурой ваш runtime - это может быть виртуальная машина или операционная система.

Идея этой структуры - организовать управление инструкциями выполнения кода в соответствии с определенными требованиями.

Пример требований - утилизировать все доступные нам ядра процессора.

Для этого мы можем с помощью потоков "дать указание" планировщику нашего runtime о том, что вот этот код нужно выполнять параллельно (на разных ядрах).

## Isolate

Изолированный (изолировать). Относительно новое понятие. Впервые я встретил его в Dart.

Вообще концепция "изолят", как я их называю, очень даже простая. 

Изолят - это коробка, в которую положили код, динамическую память (простыми словами "кучу"), какие-то атрибуты и отправили это все "плыть" по потоку.

Смысл существования изолят вот в чем - у потоков есть проблема, с которой пытаются бороться разными способами. 

Код двух потоков может изменять общие данные - состояние гонки потока. 

И чтобы этих общих данных не было - придумали изоляты.

Дополнительно, разграничение памяти по изолятам может упростить сборку мусора: просто сегментирует память и уменьшает объем сборки в рамках одного изолята.

Изоляты и потоки связаны: когда Dart хочет выполнить код, он берет этот "код" в изоляте и назначает поток, который будет выполнять код.

Вообще хорошо написал про эту архитектуру [Вячеслав Егоров](https://habr.com/ru/users/mraleph): [оригинал](https://mrale.ph/dartvm/) и [перевод](https://habr.com/ru/articles/848166/).

Кстати, если ты это читаешь, загляни [сюда](https://github.com/antonbashir/dart), может быть все же решите добавить корутины в Dart :)

## Future

В Dart есть 2 типа функций (вообще 4, но давайте остановимся на двух) - синхронные и асинхронные.

С синхронными все понятно. Обычная функция, есть результат, имя, аргументы: бери и вызывай. 

```dart
void main() {
  print("before start");
  final result = child(0);
  print("child result: $result");
  print("after start");
}

int child(int argument) {
  print("child: entry($argument)");
  return 0;
}
```

```
before start
child: entry(0)
child result: 0
after start
```

С асинхронными все весело. Сейчас покажу.

```dart
Future<void> main() async {
  print("before start");
  final result = child(0);
  print("child result: $result");
  final resultWhenReady = await result;
  print("child result when ready: $resultWhenReady");
  print("after start");
}

Future<int> child(int argument) async {
  await otherChild();
  print("child: entry($argument)");
  return 0;
}

Future<void> otherChild() async {
  print("other child");
}
```

```
before start
other child
child result: Instance of 'Future<int>'
child: entry(0)
child result when ready: 0
after start
```

Вот смотрите. `main` вызвал `child`. `child` вызвал `otherChild`. 

Получили вывод: `before start -> other child -> child result -> child: entry -> child result when ready -> after start`.

Мы сначала получили вывод из `other child`, а потом мы получили `child result` вместо того, чтобы получить `child: entry`.

В этом и есть смысл асинхронных функций: мы не "ждем" выполнения асинхронной функции, мы просто выполняем наш код дальше. 
Чтобы отслеживать состояние асинхронной функции и получить результат из нее, мы используем объект `Future`.

При этом важно отметить: в рамках одного изолята в Dart две асинхронные функции никогда не выполняются параллельно.
В один момент времени работает только один поток, который выполняет какую-то функцию (синхронную или асинхронную).

## Coroutine & Fiber

Моя прелесть. Здесь начнется самое веселое. Взгляните на это и попытайтесь осознать, что здесь происходит.

```dart
var commonState = "";

void main() {
  print("before start");
  Fiber.launch(mainEntry);
  print("after start");
}

void mainEntry() {
  print("main: entry");
  commonState += "main -> ";
  Fiber.spawn(childEntry);
  commonState += "main -> ";
  print("main: after child transfer");
  Fiber.reschedule();
  print(commonState);
}

void childEntry() {
  print("child: entry");
  commonState += "child -> ";
  Fiber.reschedule();
  commonState += "child";
}
```

```
before start
main: entry
child: entry
main: after child transfer
child: after main transfer
main -> child -> main -> child
after start
```

Итак. Мы сделали `Fiber.launch`, куда передали ссылку на функцию `mainEntry`. Здесь все легко и понятно.

Где-то внутри `Fiber.launch` мы запустили наш `mainEntry` (вывод `main: entry`). 

Далее мы запустили `Fiber.spawn`, куда передали ссылку на функцию `childEntry`. Ну тоже не очень сложно.

Там у нас как-то запустился наш `childEntry` (вывод child: entry).

Потом вызывается какой-то странный `Fiber.reschedule()` и мы видим вывод: `main: after child transfer`.

Внимание вопрос, какой такой магией мы из `childEntry()` вдруг снова оказались в `mainEntry()`, да еще и где-то в середине функции ?

Но самое интересно у нас дальше. Мы снова делаем `Fiber.reschedule()` и оказываемся в `childEntry()` O_o. 

Ответ - вот, что такое корутины. Корутина - это структура, которая позволяет нам управлять выполнением нашего кода так, как мы хотим того сами.

Я бы сказал так: поток является корутиной для того `runtime` (ОС или VM), который его выполняет. Еще корутины называют "зеленые потоки".

Ну а Ffiber ? Fiber это high-level абстракция, которая дает удобный API для управления корутинами. 

# Заглядываем под капот: Future

> [!NOTE]
> Вообще текущая реализация async в Dart (как мне кажется) реализована одним человеком - [Александр Марков](https://github.com/alexmarkov). 
> Александр, если ты это читаешь, ну добавь корутины, ну позязя :)

С чего бы начать...

Так как функционал там достаточно объемный, я бы хотел сфокусировать внимание на одном сценарии:

```dart
Future<void> main async {
  final myFuture = myFunction();
  await myFuture;
}

Future<String> myFunction() async { return "Hello, World!"; }
```

Схема выполнения кода с учетом `async-await`: 
1. Вызвалась фукнция `main()` -> 
2. Вызвали функцию `myFunction()` ->
3. Неявно создали объект `Future` -> 
4. Функция `myFunction()` завершилась -> 
5. "дождались" `myFuture` и взяли оттуда значение

И первое, что бросается в глаза - класс `Future`. Пожалуй, с чего мы и начнем.

Вообще, `Future` - это очень удобный, публичный, user-oriented класс.

Все методы прекрасно прокомментированы, да и по их названию можно понять, за что они отвечают.

Идея класса в том, чтобы предоставить разработчику необходимый набор операций над асинхронным выполнением/вычислением. 

Мы можем выстроить цепочку последовательных преобразований с помощью `then`, указать `callback` по завершению future `whenComplete`, обработать ошибки с помощью `catchError`. 

Я бы не хотел долго останавливаться на этом классе, потому что в первую очередь интересны не методы класса, а конструкция `await myFuture;`, которая позволяет дождаться результата `Future`.

Когда-нибудь задумывались, что вообще скрывается за ключевым словом `await` ?

Я вам сейчас расскажу, даже покажу. Вот оно:

```dart
@pragma("vm:entry-point", "call")
@pragma("vm:invisible")
Object? _await(Object? object) {
  if (_thenCallback == null) {
    _createAsyncCallbacks();
  }
  if (object is _Future) {
    if (object._isComplete) {
      _awaitCompletedFuture(object);
    } else {
      object._thenAwait<dynamic>(
          unsafeCast<dynamic Function(dynamic)>(_thenCallback),
          unsafeCast<dynamic Function(Object, StackTrace)>(_errorCallback));
    }
  } else if (object is! Future) {
    _awaitNotFuture(object);
  } else {
    _awaitUserDefinedFuture(object);
  }
  return _functionData;
}
```

Эта функция находится в классе `_SuspendState` и ее достаточно для реализации ключевого слова `await`. Поверили ? Зря, зря... 

К сожалению, между `await` и вызовом `_SuspendState._await` выполняется определенная магия, о которой пойдет разговор ниже.

Сейчас давайте немного замедлимся здесь и посмотрим, что происходит внутри `_SuspendState`, за что он отвечает и какая связь с `Future`.

Итак, в нашем случае нас интересуют следующие участки кода.

```dart
object._thenAwait<dynamic>(
    unsafeCast<dynamic Function(dynamic)>(_thenCallback),
    unsafeCast<dynamic Function(Object, StackTrace)>(_errorCallback));
```

и

```dart
_awaitCompletedFuture(object);
```

`_thenAwait` это функция у `_Future`. Вкратце, данная функция добавляет новый `_FutureListener` в наш Future.
Каждый `_FutureListener` это своего рода `callback`, который нужно вызвать в момент завершения Future. 
Мы можем регистрировать свои `_FutureListener` через `Future.then`. 

В случае `_SuspendState` будет вызван `_thenCallback`, который в свою очередь вызовет следующую функцию

```dart
thenCallback(value) {
  suspendState._resume(value, null, null);
}
```

`_awaitCompletedFuture` создает микротаску, которая должна вызвать `thenCallback`.

Краткая сводка о микротасках: если код Dart по каким-то причинам не выполняется, то выполняется код Dart VM (C++ часть). 

В коде Dart VM есть очередь (вообще их [несколько](https://habr.com/ru/articles/754194/)) событий и механизмы ожидания событий из этой очереди.

Микротаски - это события/задачи, которые выставляются в начало очереди задач и будут выполнены тогда, когда Dart VM освободится от выполнения Dart кода и проверит состояние очереди.

Чем тяжелее код, тем чернее пуэр... И тут мы подходим к самым увлекательным аспектам реализации `async-await` механики в Dart VM. 

Лучше всего реализация описана в [технической документации](https://github.com/dart-lang/sdk/blob/main/runtime/docs/async.md).

Я же постараюсь кратко задекларировать ключевые моменты для формирования общей картины понимания.

Забегая вперед следующей статьи, стоит сказать о таком функционале Dart VM как заглушка. 
Заглушка - это архитектурно зависимый код на языке ассемблера, который генерируется с помощью C++ кода Dart VM. 
Вот так выглядит простейшая заглушка:
```c++
void StubCodeCompiler::GenerateInitStaticFieldStub() {
  __ EnterStubFrame();
  __ PushObject(NullObject());  // Make room for result.
  __ PushRegister(InitStaticFieldABI::kFieldReg);
  __ CallRuntime(kInitStaticFieldRuntimeEntry, /*argument_count=*/1);
  __ Drop(1);
  __ PopRegister(InitStaticFieldABI::kResultReg);
  __ LeaveStubFrame();
  __ Ret();
}
```

Что здесь происходит ? Честно говоря, будучи Java/Dart/Go разработчиком, мне было не очень легко в этом разобраться. Но сложно - не значит невозможно.

Итак, давайте разберем эту простейшую заглушку:
1. `EnterStubFrame()` - сохраняет текущий указатель на фрейм (регистр `RBP`) на стек и перемещает текущий указатель на стек (регистр `RSP`) в регистр `RBP`.
2. `PushObject(NullObject())` - подготовка регистра для получения результата вызова последующей `Runtime` функции
3. `PushRegister(InitStaticFieldABI::kFieldReg)` - передаем регистр, в котором (судя по названию) находится поле, которое нужно инициализировать
4. `CallRuntime(kInitStaticFieldRuntimeEntry, /*argument_count=*/1)` - здесь мы вызываем `runtime` функцию, эта функция реализована на C++ и является частью кода Dart VM
5. `Drop(1)` - двигаем указатель на стек, чтобы добраться до результата
6. `PopRegister(InitStaticFieldABI::kResultReg)` - вытаскиваем результат и восстанавливаем баланс стека
7. `LeaveStubFrame()` - достаем указатель на стек из регистра `RBP` и вытаскиваем указатель на фрейм со стека
8. `Ret()` - возвращаемся из функции

Да, это была простейшая заглушка. А теперь попробуйте представить, как выглядят сложные.

Но вернемся к `async-await`. 

Итак, для реализации механизма `async-await` у нас используются следующие заглушки:
1. `GenerateAwaitStub`
2. `GenerateResumeStub`
2. `GenerateReturnAsyncStub`

`AwaitStub`, она же `SuspendStub` генерируется в месте вызова `await` инструкции. 
Эта заглушка отвечает за сохранение текущего контекста (фрейма) функции в определенное место (`_SuspendState`) и вызов асинхронной функции (в нашем случае вызов `myFunction`).

Логика примерно следующая: 
1. Создали `_SuspendState`, если надо
2. Подготовили стек и сохранили текущий фрейм в память
3. Вызвали асинхронную функцию
4. Удалили текущий фрейм функции
5. "Выпрыгнули" из текущей функции в функцию выше, в нашем случае мы "прыгнем" в С++ код Dart VM, который вызывает `main()` функцию

`ResumeStub` представляет реализацию функции `_SuspendState._resume` и отвечает за следующую логику:
1. Взять фрейм стека функции, которую нужно возобновить (она в данный момент "ждет" на `await`)
2. Восстановить стек, используя сохраненный фрейм стека той функции
3. Выполнить `jump` в точку инструкции, из которой была вызвана async функцию (то есть выполнение кода продолжится после этой точки)

`ReturnAsyncStub` работает достаточно просто в случае нашего примера: вызываем `_SuspendState._returnAsync`.

Итого. Наш путь вызова асинхронной функции выглядит следующим образом: 
* создали `_SuspendState` -> 
* сохранили текущий фрейм стека -> 
* вызвали функцию -> 
* завершили future через `_returnAsync` ->
* Dart VM выполнил микротаску, которая вызвала `thenCallback`, который вызвал `_resume` -> 
* "Прыгнули" в место вызова функции с восстановлением фрейма

# Заглядываем под капот: Coroutine

Не хочется пока что раскрывать секреты моих корутин, поэтому я вам покажу корутины из замечательной базы данных - [Tarantool](https://www.tarantool.io/en/).

Детальный разбор моих корутин будет в следующих статьях.

Fiber - основное понятие, с которым работает разработчик в Tarantool.

Fiber - это абстракция над корутиной. Fiber можно усыплять, пробуждать, можно `yield`-ить - выполнять смену одного (текущего) Fiber на любой Fiber, который готов к выполнению. 

За выполнение Fiber отвечает планировщик - Fiber Scheduler.

Давайте здесь рассмотрим два ключевых аспекта реализации корутин в Tarantool: 
1. Как работает смена контекста ?
2. Что делать, если никакой Fiber не готов к выполнению ?

Вот так выглядит реализация и сигнатура функции смены контексты корутины для Linux x64 в Tarantool:

```c
void coro_transfer (coro_context *prev, coro_context *next) {
  pushq %rbp
  pushq %rbx
  pushq %r12
  pushq %r13
  pushq %r14
  pushq %r15
  movq %rsp, (%rdi)
  movq (%rsi), %rsp
  popq %r15
  popq %r14
  popq %r13
  popq %r12
  popq %rbx
  popq %rbp
  popq %rcx
  jmpq *%rcx
}
```

Вкратце, что здесь происходит:
1. Мы передаем на вход контекст (стек) старой (в случае с Tarantool Fiber имеется в виду текущей корутины) и новой (следующей) корутины
2. Сохраняем [callee-saved](https://www.uclibc.org/docs/psABI-x86_64.pdf) регистры на стек
3. Двигаем текущий стек в контекст (сохраняем в память) старой корутины
4. Достаем стек из новой корутины
5. Восстанавливаем основные регистры со стека
6. "Прыгаем" в указатель на инструкцию (`%rcx`) (следующая инструкция после вызова `coro_transfer`)

По сути `coro_transfer` - это наш "попрыгун" между корутинами. Все операции Tarantool Fiber, в которых нужно сменить корутину, выполняются через эту функцию.

Что касательно второго вопроса: это реализуется через связку `coro_transfer` и `Event Loop`. 

Про реализацию разных `Event Loop` можно почитать, например, [тут](https://libev.schmorp.narkive.com/hKCGdLbP/and-ent), ну а в Tarantool используется [libev](https://github.com/enki/libev) библиотечка.

Рассмотрим алгоритм функции [sleep](https://www.tarantool.io/en/doc/latest/reference/reference_lua/fiber/#lua-function.fiber.sleep):
1. Регистрируем таймер с помощью libev
2. Привязываем таймер к функции, которая должна будет "разбудить" наш Fiber
3. Выполняем `yield`, он же - смена контекста на нашего вызывателя
4. Если мы сменили контекст на планировщика, и ему некого планировать, он обратится к libev
5. Когда libev ответит, что событие таймера сработало, вызовется наша функция, которая скажет планировщику - "у тебя появился готовый к работе Fiber"

Практически все fiber-related операции в Tarantool выполняются через связку libev и [libcoro](https://github.com/semistrict/libcoro)

Есть еще один прекрасный пример реализации корутин, кроссплатформенный, даже Эльбрус поддерживает. Лежит он вот [тут](https://github.com/taisei-project/koishi)

Собственно, в своей работе я и решил опираться на эти замечательные примеры. Во всяком случае я планировал так сделать. 

Получилось не очень :) 

# И зачем это все ? 

Серьезно, в чем смысл ? Реализация у async выглядит вполне себе достойной. 

Не скажу, что я жестко тестировал ее с точки зрения производительности, но те редкие бенчи, которые я делал, мне были ок.

Суть тут не в производительности. Суть в гибкости и функциональности. 

У меня возник приблизительно следующий список требований к функционалу асинхронного управления:
* я не хочу использовать дополнительные объекты [Completer](https://api.flutter.dev/flutter/dart-async/Completer-class.html) для фиксации suspend/resume точек
* я хочу бесшовную интеграцию с [FFI](https://dart.dev/interop/c-interop): то есть, когда из native уровня сработало событие, я хочу, чтобы корутина на Dart уровне была тут же разбужена без накладных расходов
* меня не очень устроил объем вспомогательного Dart кода внутри Future: кажется, это можно сделать попроще
* абсолютно не нравится, что код превращается из единой модели в две, среди которых нет удобных переходов: `sync` функции и `async` легко не [свяжешь](https://github.com/dart-lang/sdk/issues/39390)
* шило в... короче, велосипедная тяга - стало интересно это реализовать :) 

# Немного про Dartino 

Перед тем как пойти делать свою реализацию, мне стало интересно: может быть уже что-то имеется. И да, кое-что есть. 

Встречайте, [Dartino!](https://github.com/dart-archive/sdk)

Dartino это реализация Dart VM под embedded устройства. Она оказалась [заброшена](https://groups.google.com/g/dartino-discuss/c/U3fzZjoOdKg/m/0CB8ON6RCAAJ).

Но посмотрите, что я смог в ней найти:

```c++
void InterpreterGeneratorX64::DoCoroutineChange() {
  LoadLiteralNull(RAX);

  LoadLocal(RBX, 0);  // Load argument.
  LoadLocal(RSI, 1);  // Load coroutine.

  StoreLocal(RAX, 0);
  StoreLocal(RAX, 1);

  Label resume;
  SaveState(&resume);
  LoadProcess(RDI);
  // RSI already loaded with coroutine.
  __ call("HandleCoroutineChange");
  RestoreState();

  __ Bind(&resume);
  __ Bind("", "InterpreterCoroutineEntry");

  StoreLocal(RBX, 1);
  Drop(1);

  Dispatch(kCoroutineChangeLength);
}
```

Да, это Dart корутины.

Чуть дальше я буду рассказывать о своих ощущениях на этом этапе моего пути, но, когда я увидел, что есть версия Dart, в котором есть то, что мне нужно и я не могу её использовать, мне стало грустно.

Дело даже не в том, что я не смогу сократить объем своей работы, так как бесполезно пытаться ориентироваться на Dartino, когда работаешь с Dart VM. 

Дело в том, что оказывается 10 лет назад была легковесная, маленькая реализация Dart, которую просто забросили. Расстраивает сам факт того, что столько работы осталось без применения, без развития. 

# Что с мотивацией ?

Как и обещал, фиксирую свое состояние на этом этапе разработки.
Я был расстроен из-за Dartino, но моя уверенность и мой настрой не потерялись.
Я нашел много красивых реализаций корутин, которые я могу использовать для разработки.

Кстати, команде Tarantool огромное спасибо за OpenSource! Это правда нужно миру. Пожалуйста, развивайте его.

После моего небольшого анализа и поисков примеров для реализации мой уровень решимости - 90%, потому что Dartino правда расстроил.

Нет, серьезно, склонируйте себе репозиторий, посмотрите на код, почитайте, может быть среди вас найдется тот, кто сможет возродить этот проект.

# Пошла жара

Следующая статья будет максимально технической. Я собираюсь рассказать о том, что из себя представляет реализация корутин на Dart.
Какие аспекты Dart VM пришлось затронуть. Какие особенности Dart мне мешали, а какие помогали на моем пути. 

Разумеется, будет фиксация моего состояния к моменту создания первого рабочего прототипа.

Приглашаю посмотреть на жесткий технический BDSM ( Breaking Dart Stub Manipulation ). Тыкайте [сюда](/blog/ru/dart-3).

Спасибо за внимание !