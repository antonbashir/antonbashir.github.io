---
title: "О времени, сложности и мотивации: корутины и/или асинхронные функции ?"
description: Мои приключения в мире DartVM. Часть 2. 
date: 11-04-2025
label: Article
tags: IT, Dart, DartVM, ASM, Coroutines, Complicated
time: 10 min
---

Приветствую тебя читатель. Для начала я рекомендую тебе ознакомиться с первой частью моего цикла статей.
В этом цикле я пишу о балансе, состояниях разработчика, корутинах и Dart.
Это вторая часть из пяти и здесь я собираюсь познакомить тебя с основными виновниками этих статей - корутины и асинхронные функции (они же Futures в терминах Dart).

# Об авторе

Меня зовут Антон и я "чайный" программист-даос. 
Я 10 лет пишу код на разных языках, увлекаюсь даосизмом, китайским чаем и созданием никому не нужных велосипедов. 
Чуть подробнее обо мне тут (ссылка на первую часть)

# Поговорим про понятия

Итак, с чем мы работаем:
* Thread 
* Isolate
* Future
* Coroutine & Fiber

Теперь я постараюсь дать мои собственные (то, как у меня в голове они сформулированы) определения этим понятиям с учетом работы с Dart.

Thread. Поток, нить - так его называют. Вообще концепция потока присутствует во многих языках, с которыми я работал. 
Всегда эта концепция представляет собой что-то, что нужно использовать для параллельного выполнения кода. 
Я раскрываю эту концепцию таким образом: поток - это структура, содержащая стек, хранилище, атрибуты, состояние, (что-то еще в зависимости от реализации). 
Управляет этой структурой ваш runtime - это может быть виртуальная машина или операционная система. 
Идея этой структуры (сейчас будет сложно) - организовать управление инструкциями выполнения кода в соответствии с определенными требованиями. 
Пример требований - мы утилизировать доступные нам ядра процессора. 
Для этого мы можем с помощью потоков "дать указание" планировщику нашего runtime о том, что вот этот код нужно выполнять параллельно (на разных ядрах).

Isolate. Изолированный (изолировать). Относительно новое понятие. В Linux Kernel я такое не встречал. Я познакомился с этим понятием только в Dart. 
Вообще концепция "изолят", как я их называю, очень даже простая. 
Изолят - это коробка, в которую положили код, динамическую память (в простонародии кучу), какие-то атрибуты и отправили это все "плыть" по потоку.
Смысл существования изолят вот в чем - у потоков есть проблема, с которой пытаются бороться разными способами. 
Код двух потоков может изменять общие данные - состояние гонки потока. 
И чтобы этих общих данных не было (а еще и общего кода, why not), придумали изоляты. 
Плюс ко всему, разграничение памяти по изолятам может упростить сборку мусора: банально меньше собирать.
Изоляты и потоки связаны: когда Dart хочет выполнить код, он берет этот "код" в изоляте и назначает поток, который будет выполнять код.

Вообще хорошо написал про эту архитектуру Вячеслав Егоров (ссылка на оригинал и перевод). 
Кстати, если ты это читаешь, загляни в PR, может быть все же решите добавить корутины в Dart :)

Future. В Dart есть 2 типа функций (вообще 4, но давайте остановимся на двух) - синхронные и асинхронные.
С синхронными все понятно, обычная функция, есть результат, имя, аргументы: бери и вызывай. 
```
void main() {
  print("before start");
  final result = child(0);
  print("child result: $result");
  print("after start");
}

int child(int argument) {
  print("child: entry($argument)");
  return 0;
}
```

```
before start
child: entry(0)
child result: 0
after start
```

С асинхронными все весело. Сейчас покажу.

```
Future<void> main() async {
  print("before start");
  final result = child(0);
  print("child result: $result");
  final resultWhenReady = await result;
  print("child result when ready: $resultWhenReady");
  print("after start");
}

Future<int> child(int argument) async {
  await otherChild();
  print("child: entry($argument)");
  return 0;
}

Future<void> otherChild() async {
  print("other child");
}
```

```
before start
other child
child result: Instance of 'Future<int>'
child: entry(0)
child result when ready: 0
after start
```

Вот смотрите. main вызвал child. child вызвал otherChild. 
И посмотрите на вывод:
`before start -> other child -> child result -> child: entry -> child result when ready -> after start`
Мы сначала получили вывод из other child, а потом мы получили child result вместо того, чтобы получить `child: entry`.
В этом и есть смысл асинхронных функций: если мы не "ждем" выполнения асинхронной функции мы просто выполняем наш код дальше. 
Чтобы отслеживать состояние асинхронной функции и получить результат из нее, мы используем объект Future.
При этом важно отметить: в рамках одного изолята в Dart две асинхронные функции никогда не выполняются параллельно.
В один момент времени работает только один поток, который выполняет какую-то функцию (синхронную или асинхронную). 

Coroutine & Fiber. Моя прелесть. Здесь начнется самое веселое. Взгляните на это и попытайтесь осознать, что здесь происходит.

```
var commonState = "";

void main() {
  print("before start");
  Fiber.launch(mainEntry);
  print("after start");
}

void mainEntry() {
  print("main: entry");
  commonState += "main -> ";
  Fiber.spawn(childEntry);
  commonState += "main -> ";
  print("main: after child transfer");
  Fiber.reschedule();
  print(commonState);
}

void childEntry() {
  print("child: entry");
  commonState += "child -> ";
  Fiber.reschedule();
  commonState += "child";
}
```

```
before start
main: entry
child: entry
main: after child transfer
child: after main transfer
main -> child -> main -> child
after start
```

Итак. Мы сделали Fiber.launch, куда передали ссылку на функцию `mainEntry`. Здесь все легко и понятно. 
Где-то внутри Fiber.launch мы запустили наш mainEntry (вывод `main: entry`). 
Далее мы запустили Fiber.spawn, куда передали ссылку на функцию `childEntry`. Ну тоже не очень сложно. 
Там у нас как-то запустился наш `childEntry` (вывод child: entry).
Потом вызывается какой-то странный `Fiber.reschedule()` и мы видим вывод: `main: after child transfer`. 
Внимание вопрос, какой такой магией мы из childEntry() вдруг снова оказались в mainEntry(), да еще и где-то в середине функции ?
Но самое интересно у нас дальше. Мы снова делаем Fiber.reschedule() иии оказываемся в childEntry() O_o. 
Ответ - вот, что такое coroutine :) Coroutine это структура, которая позволяет нам управлять исполнением нашего кода так, как мы хотим того сами. 
Я бы сказал так. Thread является Coroutine для того runtime (ОС или VM), который его выполняет. Еще корутины называют "зеленые потоки". 
Ну а fiber, fiber это high-level абстракция, которая дает удобный API для управления корутинами. 


# Заглядываем под капот: Future
Вообще текущая реализация async в Dart (как мне кажется) реализована одним человеком - Александр Марков. 
Александр, если ты это читаешь, ну добавь корутины, ну позязя :)

TODO: А это прям сложно



# Заглядываем под капот: Coroutine

Не хочется пока что раскрывать секреты моих корутин, поэтому я вам покажу корутины из замечательной (прям ну очень шикарной) базы данных - Tarantool.
Детальный разбор моих корутин будет в следующих статьях.

TODO: А это прям сложно


# И зачем это все ? Какой смысл делать корутины ?



# Немного про Dartino 


# Show me your motivation


# Пошла жара



А пока что я с вами прощаюсь, давайте сделаем перерыв, отвлечемся, развлечемся и для тех, кто готов послушать дальше - welcome.

Спасибо за внимание ! 