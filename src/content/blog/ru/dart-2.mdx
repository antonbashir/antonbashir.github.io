---
title: "О времени, сложности и мотивации: корутины и/или асинхронные функции ?"
description: Мои приключения в мире DartVM. Часть 2. 
date: 11-04-2025
label: Article
tags: IT, Dart, DartVM, ASM, Coroutines, Complicated
time: 10 min
---

Приветствую тебя читатель. Для начала я рекомендую тебе ознакомиться с первой частью моего цикла статей.
В этом цикле я пишу о балансе, состояниях разработчика, корутинах и Dart.
Это вторая часть из пяти и здесь я собираюсь познакомить тебя с основными виновниками этих статей - корутины и асинхронные функции (они же Futures в терминах Dart).

# Об авторе

Меня зовут Антон и я "чайный" программист-даос.
Я 10 лет пишу код на разных языках, увлекаюсь даосизмом, китайским чаем и созданием никому не нужных велосипедов. 
Чуть подробнее обо мне тут (ссылка на первую часть)

# Поговорим про понятия

Итак, с чем мы работаем:
* Thread 
* Isolate
* Future
* Coroutine & Fiber

Теперь я постараюсь дать мои собственные (то, как у меня в голове они сформулированы) определения этим понятиям с учетом работы с Dart.

Thread. Поток, нить - так его называют. Вообще концепция потока присутствует во многих языках, с которыми я работал. 
Всегда эта концепция представляет собой что-то, что нужно использовать для параллельного выполнения кода. 
Я раскрываю эту концепцию таким образом: поток - это структура, содержащая стек, хранилище, атрибуты, состояние, (что-то еще в зависимости от реализации). 
Управляет этой структурой ваш runtime - это может быть виртуальная машина или операционная система. 
Идея этой структуры (сейчас будет сложно) - организовать управление инструкциями выполнения кода в соответствии с определенными требованиями. 
Пример требований - мы утилизировать доступные нам ядра процессора. 
Для этого мы можем с помощью потоков "дать указание" планировщику нашего runtime о том, что вот этот код нужно выполнять параллельно (на разных ядрах).

Isolate. Изолированный (изолировать). Относительно новое понятие. В Linux Kernel я такое не встречал. Я познакомился с этим понятием только в Dart. 
Вообще концепция "изолят", как я их называю, очень даже простая. 
Изолят - это коробка, в которую положили код, динамическую память (в простонародии кучу), какие-то атрибуты и отправили это все "плыть" по потоку.
Смысл существования изолят вот в чем - у потоков есть проблема, с которой пытаются бороться разными способами. 
Код двух потоков может изменять общие данные - состояние гонки потока. 
И чтобы этих общих данных не было (а еще и общего кода, why not), придумали изоляты. 
Плюс ко всему, разграничение памяти по изолятам может упростить сборку мусора: банально меньше собирать.
Изоляты и потоки связаны: когда Dart хочет выполнить код, он берет этот "код" в изоляте и назначает поток, который будет выполнять код.

Вообще хорошо написал про эту архитектуру Вячеслав Егоров (ссылка на оригинал и перевод). 
Кстати, если ты это читаешь, загляни в PR, может быть все же решите добавить корутины в Dart :)

Future. В Dart есть 2 типа функций (вообще 4, но давайте остановимся на двух) - синхронные и асинхронные.
С синхронными все понятно, обычная функция, есть результат, имя, аргументы: бери и вызывай. 
```
void main() {
  print("before start");
  final result = child(0);
  print("child result: $result");
  print("after start");
}

int child(int argument) {
  print("child: entry($argument)");
  return 0;
}
```

```
before start
child: entry(0)
child result: 0
after start
```

С асинхронными все весело. Сейчас покажу.

```
Future<void> main() async {
  print("before start");
  final result = child(0);
  print("child result: $result");
  final resultWhenReady = await result;
  print("child result when ready: $resultWhenReady");
  print("after start");
}

Future<int> child(int argument) async {
  await otherChild();
  print("child: entry($argument)");
  return 0;
}

Future<void> otherChild() async {
  print("other child");
}
```

```
before start
other child
child result: Instance of 'Future<int>'
child: entry(0)
child result when ready: 0
after start
```

Вот смотрите. main вызвал child. child вызвал otherChild. 
И посмотрите на вывод:
`before start -> other child -> child result -> child: entry -> child result when ready -> after start`
Мы сначала получили вывод из other child, а потом мы получили child result вместо того, чтобы получить `child: entry`.
В этом и есть смысл асинхронных функций: если мы не "ждем" выполнения асинхронной функции мы просто выполняем наш код дальше. 
Чтобы отслеживать состояние асинхронной функции и получить результат из нее, мы используем объект Future.
При этом важно отметить: в рамках одного изолята в Dart две асинхронные функции никогда не выполняются параллельно.
В один момент времени работает только один поток, который выполняет какую-то функцию (синхронную или асинхронную). 

Coroutine & Fiber. Моя прелесть. Здесь начнется самое веселое. Взгляните на это и попытайтесь осознать, что здесь происходит.

```
var commonState = "";

void main() {
  print("before start");
  Fiber.launch(mainEntry);
  print("after start");
}

void mainEntry() {
  print("main: entry");
  commonState += "main -> ";
  Fiber.spawn(childEntry);
  commonState += "main -> ";
  print("main: after child transfer");
  Fiber.reschedule();
  print(commonState);
}

void childEntry() {
  print("child: entry");
  commonState += "child -> ";
  Fiber.reschedule();
  commonState += "child";
}
```

```
before start
main: entry
child: entry
main: after child transfer
child: after main transfer
main -> child -> main -> child
after start
```

Итак. Мы сделали Fiber.launch, куда передали ссылку на функцию `mainEntry`. Здесь все легко и понятно. 
Где-то внутри Fiber.launch мы запустили наш mainEntry (вывод `main: entry`). 
Далее мы запустили Fiber.spawn, куда передали ссылку на функцию `childEntry`. Ну тоже не очень сложно. 
Там у нас как-то запустился наш `childEntry` (вывод child: entry).
Потом вызывается какой-то странный `Fiber.reschedule()` и мы видим вывод: `main: after child transfer`. 
Внимание вопрос, какой такой магией мы из childEntry() вдруг снова оказались в mainEntry(), да еще и где-то в середине функции ?
Но самое интересно у нас дальше. Мы снова делаем Fiber.reschedule() иии оказываемся в childEntry() O_o. 
Ответ - вот, что такое coroutine :) Coroutine это структура, которая позволяет нам управлять исполнением нашего кода так, как мы хотим того сами. 
Я бы сказал так. Thread является Coroutine для того runtime (ОС или VM), который его выполняет. Еще корутины называют "зеленые потоки". 
Ну а fiber, fiber это high-level абстракция, которая дает удобный API для управления корутинами. 


# Заглядываем под капот: Future
Вообще текущая реализация async в Dart (как мне кажется) реализована одним человеком - Александр Марков. 
Александр, если ты это читаешь, ну добавь корутины, ну позязя :)

TODO: А это прям сложно



# Заглядываем под капот: Coroutine

Не хочется пока что раскрывать секреты моих корутин, поэтому я вам покажу корутины из замечательной (прям ну очень шикарной) базы данных - Tarantool.
Детальный разбор моих корутин будет в следующих статьях.

TODO: А это прям сложно


# И зачем это все ? Какой смысл делать корутины ?

Серьезно, в чем смысл ? Реализация у async выглядит вполне себе достойной. 
Не скажу, что я жестко тестировал ее с точки зрения производительности, но те редкие бенчи, которые я делал (и не пушил их в гитхаб) мне были ок. 
Суть тут не в производительности. Суть в гибкости и функциональности. 

У меня возник приблизительно следующий список требований к функционалу асинхронного управления:
* я не хочу использовать дополнительные объекты (Completer) для фиксации suspend/resume точек (очевидно, экономия памяти и cpu на создание объектов)
* я хочу бесшовную интеграцию с FFI IOUring: то есть, когда из native уровня сработало событие, я хочу, чтобы корутина на Dart уровне была тут же разбужена без накладных расходов
* меня не очень устроил объем вспомогательного Dart кода внутри Future: кажется, это можно сделать попроще
* абсолютно не нравится, что код превращается из единой модели в две, среди которых нет удобных переходов: sync функции и async легко не свяжешь (https://github.com/dart-lang/sdk/issues/39390)
* шило в ... короче, стало интересно это реализовать :) 


# Немного про Dartino 

Перед тем как пойти делать свою реализацию, мне стало интересно: может быть уже что-то имеется. И да, кое-что есть. 
Встречайте Dartino! https://github.com/dart-archive/sdk
Dartino это реализация DartVM под embedded устройства. Она оказалась заброшена (ссылка на инфу). 
Но посмотрите, что я смог в ней найти:

<сюда картинку>

Да, это dart-корутины. Даже есть вот такая вот функция смены контекста:
```
void InterpreterGeneratorX64::DoCoroutineChange() {
  LoadLiteralNull(RAX);

  LoadLocal(RBX, 0);  // Load argument.
  LoadLocal(RSI, 1);  // Load coroutine.

  StoreLocal(RAX, 0);
  StoreLocal(RAX, 1);

  Label resume;
  SaveState(&resume);
  LoadProcess(RDI);
  // RSI already loaded with coroutine.
  __ call("HandleCoroutineChange");
  RestoreState();

  __ Bind(&resume);
  __ Bind("", "InterpreterCoroutineEntry");

  StoreLocal(RBX, 1);
  Drop(1);

  Dispatch(kCoroutineChangeLength);
}
```
Чуть дальше я буду рассказывать о своих ощущениях на этом этапе моего пути, но когда я увидел, что есть Dart, в котором есть то, что  мне нужно и он.. отменен, признаюсь честно, мне стало очень грустно. 
Дело даже не в том, что я не смогу сократить объем своей работы (бесполезно пытаться ориентироваться на Dartino, когда работаешь с DartVM). 
Дело в том, что оказывается 10 лет назад была легковесная, маленькая реализация Dart, которую просто забросили. Сам факт того, что столько работы осталось без применения, без развития. 

# Show me your motivation

Как и обещал, фиксирую свое состояние на этом этапе разработки. 
Я был расстроен из-за Dartino, но моя уверенность и мой настрой не потерялись. 
Я нашел много красивых реализаций корутин, которые я могу использовать для разработки. 
Кстати, команде Tarantool огромное спасибо за OpenSource, это правда нужно миру, не забрасывайте его, пожалуйста.



# Пошла жара



А пока что я с вами прощаюсь, давайте сделаем перерыв, отвлечемся, развлечемся и для тех, кто готов послушать дальше - welcome.

Спасибо за внимание ! 