---
title: "О времени, сложности и мотивации: корутины и/или асинхронные функции ?"
description: Мои приключения в мире DartVM. Часть 2. 
date: 11-04-2025
label: Article
tags: IT, Dart, DartVM, ASM, Coroutines, Complicated
time: 10 min
---

Приветствую тебя читатель. Для начала я рекомендую тебе ознакомиться с первой частью моего цикла статей.
В этом цикле я пишу о балансе, состояниях разработчика, корутинах и Dart.
Это вторая часть из пяти и здесь я собираюсь познакомить тебя с основными виновниками этих статей - корутины и асинхронные функции (они же Futures в терминах Dart).

# Об авторе

Меня зовут Антон и я "чайный" программист-даос.
Я 10 лет пишу код на разных языках, увлекаюсь даосизмом, китайским чаем и созданием никому не нужных велосипедов. 
Чуть подробнее обо мне тут (ссылка на первую часть)

# Поговорим про понятия

Итак, с чем мы работаем:
* Thread 
* Isolate
* Future
* Coroutine & Fiber

Теперь я постараюсь дать мои собственные (то, как у меня в голове они сформулированы) определения этим понятиям с учетом работы с Dart.

Thread. Поток, нить - так его называют. Вообще концепция потока присутствует во многих языках, с которыми я работал. 
Всегда эта концепция представляет собой что-то, что нужно использовать для параллельного выполнения кода. 
Я раскрываю эту концепцию таким образом: поток - это структура, содержащая стек, хранилище, атрибуты, состояние, (что-то еще в зависимости от реализации). 
Управляет этой структурой ваш runtime - это может быть виртуальная машина или операционная система. 
Идея этой структуры (сейчас будет сложно) - организовать управление инструкциями выполнения кода в соответствии с определенными требованиями. 
Пример требований - мы утилизировать доступные нам ядра процессора. 
Для этого мы можем с помощью потоков "дать указание" планировщику нашего runtime о том, что вот этот код нужно выполнять параллельно (на разных ядрах).

Isolate. Изолированный (изолировать). Относительно новое понятие. В Linux Kernel я такое не встречал. Я познакомился с этим понятием только в Dart. 
Вообще концепция "изолят", как я их называю, очень даже простая. 
Изолят - это коробка, в которую положили код, динамическую память (в простонародии кучу), какие-то атрибуты и отправили это все "плыть" по потоку.
Смысл существования изолят вот в чем - у потоков есть проблема, с которой пытаются бороться разными способами. 
Код двух потоков может изменять общие данные - состояние гонки потока. 
И чтобы этих общих данных не было (а еще и общего кода, why not), придумали изоляты. 
Плюс ко всему, разграничение памяти по изолятам может упростить сборку мусора: банально меньше собирать.
Изоляты и потоки связаны: когда Dart хочет выполнить код, он берет этот "код" в изоляте и назначает поток, который будет выполнять код.

Вообще хорошо написал про эту архитектуру Вячеслав Егоров (ссылка на оригинал и перевод). 
Кстати, если ты это читаешь, загляни в PR, может быть все же решите добавить корутины в Dart :)

Future. В Dart есть 2 типа функций (вообще 4, но давайте остановимся на двух) - синхронные и асинхронные.
С синхронными все понятно, обычная функция, есть результат, имя, аргументы: бери и вызывай. 
```
void main() {
  print("before start");
  final result = child(0);
  print("child result: $result");
  print("after start");
}

int child(int argument) {
  print("child: entry($argument)");
  return 0;
}
```

```
before start
child: entry(0)
child result: 0
after start
```

С асинхронными все весело. Сейчас покажу.

```
Future<void> main() async {
  print("before start");
  final result = child(0);
  print("child result: $result");
  final resultWhenReady = await result;
  print("child result when ready: $resultWhenReady");
  print("after start");
}

Future<int> child(int argument) async {
  await otherChild();
  print("child: entry($argument)");
  return 0;
}

Future<void> otherChild() async {
  print("other child");
}
```

```
before start
other child
child result: Instance of 'Future<int>'
child: entry(0)
child result when ready: 0
after start
```

Вот смотрите. main вызвал child. child вызвал otherChild. 
И посмотрите на вывод: `before start -> other child -> child result -> child: entry -> child result when ready -> after start`
Мы сначала получили вывод из other child, а потом мы получили child result вместо того, чтобы получить `child: entry`.
В этом и есть смысл асинхронных функций: мы не "ждем" выполнения асинхронной функции, мы просто выполняем наш код дальше. 
Чтобы отслеживать состояние асинхронной функции и получить результат из нее, мы используем объект Future.
При этом важно отметить: в рамках одного изолята в Dart две асинхронные функции никогда не выполняются параллельно.
В один момент времени работает только один поток, который выполняет какую-то функцию (синхронную или асинхронную). 

Coroutine & Fiber. Моя прелесть. Здесь начнется самое веселое. Взгляните на это и попытайтесь осознать, что здесь происходит.

```
var commonState = "";

void main() {
  print("before start");
  Fiber.launch(mainEntry);
  print("after start");
}

void mainEntry() {
  print("main: entry");
  commonState += "main -> ";
  Fiber.spawn(childEntry);
  commonState += "main -> ";
  print("main: after child transfer");
  Fiber.reschedule();
  print(commonState);
}

void childEntry() {
  print("child: entry");
  commonState += "child -> ";
  Fiber.reschedule();
  commonState += "child";
}
```

```
before start
main: entry
child: entry
main: after child transfer
child: after main transfer
main -> child -> main -> child
after start
```

Итак. Мы сделали Fiber.launch, куда передали ссылку на функцию `mainEntry`. Здесь все легко и понятно. 
Где-то внутри Fiber.launch мы запустили наш mainEntry (вывод `main: entry`). 
Далее мы запустили Fiber.spawn, куда передали ссылку на функцию `childEntry`. Ну тоже не очень сложно. 
Там у нас как-то запустился наш `childEntry` (вывод child: entry).
Потом вызывается какой-то странный `Fiber.reschedule()` и мы видим вывод: `main: after child transfer`. 
Внимание вопрос, какой такой магией мы из childEntry() вдруг снова оказались в mainEntry(), да еще и где-то в середине функции ?
Но самое интересно у нас дальше. Мы снова делаем Fiber.reschedule() иии оказываемся в childEntry() O_o. 
Ответ - вот, что такое coroutine :) Coroutine это структура, которая позволяет нам управлять исполнением нашего кода так, как мы хотим того сами. 
Я бы сказал так. Thread является Coroutine для того runtime (ОС или VM), который его выполняет. Еще корутины называют "зеленые потоки". 
Ну а fiber, fiber это high-level абстракция, которая дает удобный API для управления корутинами. 

# Заглядываем под капот: Future
Вообще текущая реализация async в Dart (как мне кажется) реализована одним человеком - Александр Марков. 
Александр, если ты это читаешь, ну добавь корутины, ну позязя :)

С чего бы начать...

Так как функционал там достаточно объемный, я бы хотел сфокусировать ваше внимание на одном сценарии:
```
Future<void> main async {
  final myFuture = myFunction();
  await myFuture;
}

Future<void> myFunction() async {}
```

Схема выполнения кода с учетом `async-await` механизма представлена ниже.

(сюда схему)

И первое, что бросается в глаза - класс `Future`. Пожалуй, с чего мы и начнем.

Вообще `Future` это максимально публичный, user-oriented класс. Все методы прекрасно прокомментированы, да и по названию можно понять, за что они отвечают. 
Идея класса в том, чтобы предоставить разработчику необходимый набор операций над асинхронным выполнением/вычислением. 
Мы можем выстроить цепочку последовательных преобразований с помощью `then`, указать callback по завершению future `whenComplete`, обработать ошибки с помощью `catchError`. 
Я бы не хотел долго останавливаться на этом классе, потому что в первую очередь интересны не методы класса, а конструкция `await myFuture;`, которая позволяет дождаться результата future.
Когда-нибудь задумывались, что вообще скрывается за ключевым словом `await` ?

Я вам сейчас расскажу, даже покажу. Вот оно:
```
  @pragma("vm:entry-point", "call")
  @pragma("vm:invisible")
  Object? _await(Object? object) {
    if (_thenCallback == null) {
      _createAsyncCallbacks();
    }
    if (object is _Future) {
      if (object._isComplete) {
        _awaitCompletedFuture(object);
      } else {
        object._thenAwait<dynamic>(
            unsafeCast<dynamic Function(dynamic)>(_thenCallback),
            unsafeCast<dynamic Function(Object, StackTrace)>(_errorCallback));
      }
    } else if (object is! Future) {
      _awaitNotFuture(object);
    } else {
      _awaitUserDefinedFuture(object);
    }
    return _functionData;
  }
```
Эта функция находится в классе _SuspendState и ее достаточно для выполнения ключевого слова `await`.
Поверили ? Зря :) К сожалению, между `await` и `вызовом _SuspendState._await` выполняется определенная магия, о которой пойдет разговор ниже.
Сейчас давайте немного замедлимся здесь и посмотрим, что происходит внутри `_SuspendState`, за что он отвечает и какая связь с `Future`.

Итак, в нашем случае нас интересует следующий участок кода.
```
object._thenAwait<dynamic>(
    unsafeCast<dynamic Function(dynamic)>(_thenCallback),
    unsafeCast<dynamic Function(Object, StackTrace)>(_errorCallback));
```

`_thenAwait` это функция у `_Future`. Вкратце, данная функция добавляет новый `_FutureListener` в наш Future.
Каждый `_FutureListener` это своего рода callback, который нужно вызвать в момент завершения Future. 
Мы можем регистрировать свои `_FutureListener` через `Future.then`. 
В случае `_SuspendState` будет вызван `_thenCallback`, который в свою очередь вызовет следующую функцию
```
thenCallback(value) {
  suspendState._resume(value, null, null);
}
```
Чем тяжелее код, тем чернее пуэр... И тут мы подходим к двум самым увлекательным аспектам реализации `async-await` механики в DartVM. 
Лучше всего описана эта реализация в технической документации (ссылка на async.md). 
Я же постараюсь кратко задекларировать ключевые моменты для формирования общей картины понимания.

Забегая вперед следующей статьи, стоит сказать о таком функционале DartVM как Stub. 
Stub это архитектурно зависимый код на языке ассемблера, который генерируется с помощью C++ кода DartVM. 
Вот так выглядит простейшая `Stub`:
```
void StubCodeCompiler::GenerateInitStaticFieldStub() {
  __ EnterStubFrame();
  __ PushObject(NullObject());  // Make room for result.
  __ PushRegister(InitStaticFieldABI::kFieldReg);
  __ CallRuntime(kInitStaticFieldRuntimeEntry, /*argument_count=*/1);
  __ Drop(1);
  __ PopRegister(InitStaticFieldABI::kResultReg);
  __ LeaveStubFrame();
  __ Ret();
}
```

Что здесь происходит ? Честно говоря, будучи JavaDartGo разработчиком, мне было не очень-то и просто в этом разобраться. Но сложно - не значит невозможно.

Итак, давайте разберем эту простейшую "стабу":
1. `EnterStubFrame()` - сохраняет текущий указатель на фрейм (регистр RBP) на стек и перемещает текущий указатель на стек (регистр RSP) в регистр RBP. 
2. `PushObject(NullObject())` - подготовка регистра для получения результата вызова последующей Runtime функции
3. `PushRegister(InitStaticFieldABI::kFieldReg)` - передаем регистр, в котором (судя по названию) находится поле, которое нужно инициализировать
4. `CallRuntime(kInitStaticFieldRuntimeEntry, /*argument_count=*/1)` - здесь мы вызываем runtime функцию, эта функция реализована на C++ и является частью кода DartVM
5. `Drop(1)` - двигаем указатель на стек, чтобы добраться до результата
6. `PopRegister(InitStaticFieldABI::kResultReg)` - вытаскиваем результат и восстанавливаем баланс стека
7. `LeaveStubFrame()` - достаем указатель на стек из регистра RBP и вытаскиваем указатель на фрейм со стека
8. `Ret()` - возвращаемся из функции

Да, это была простейшая Stub. Голова не заболела ? :) У меня вот болела, пока я копался в этом.

Но вернемся к `async-await`. 

# Заглядываем под капот: Coroutine

Не хочется пока что раскрывать секреты моих корутин, поэтому я вам покажу корутины из замечательной (прям ну очень шикарной) базы данных - Tarantool.
Детальный разбор моих корутин будет в следующих статьях.

(сюда схему)


TODO: А это прям сложно


# И зачем это все ? Какой смысл делать корутины ?

Серьезно, в чем смысл ? Реализация у async выглядит вполне себе достойной. 
Не скажу, что я жестко тестировал ее с точки зрения производительности, но те редкие бенчи, которые я делал (и не выкладывал их на гитхаб) мне были ок. 
Суть тут не в производительности. Суть в гибкости и функциональности. 

У меня возник приблизительно следующий список требований к функционалу асинхронного управления:

* я не хочу использовать дополнительные объекты (Completer) для фиксации suspend/resume точек (очевидно, экономия памяти и cpu на создание объектов)
* я хочу бесшовную интеграцию с FFI: то есть, когда из native уровня сработало событие, я хочу, чтобы корутина на Dart уровне была тут же разбужена без накладных расходов
* меня не очень устроил объем вспомогательного Dart кода внутри Future: кажется, это можно сделать попроще
* абсолютно не нравится, что код превращается из единой модели в две, среди которых нет удобных переходов: sync функции и async легко не свяжешь (https://github.com/dart-lang/sdk/issues/39390)
* шило в ... короче, велосипедная тяга - стало интересно это реализовать :) 

# Немного про Dartino 

Перед тем как пойти делать свою реализацию, мне стало интересно: может быть уже что-то имеется. И да, кое-что есть. 
Встречайте, Dartino! https://github.com/dart-archive/sdk
Dartino это реализация DartVM под embedded устройства. Она оказалась заброшена (ссылка на инфу). 
Но посмотрите, что я смог в ней найти:

(сюда картинку)

Да, это Dart корутины. Даже есть вот такая вот функция смены контекста:
```
void InterpreterGeneratorX64::DoCoroutineChange() {
  LoadLiteralNull(RAX);

  LoadLocal(RBX, 0);  // Load argument.
  LoadLocal(RSI, 1);  // Load coroutine.

  StoreLocal(RAX, 0);
  StoreLocal(RAX, 1);

  Label resume;
  SaveState(&resume);
  LoadProcess(RDI);
  // RSI already loaded with coroutine.
  __ call("HandleCoroutineChange");
  RestoreState();

  __ Bind(&resume);
  __ Bind("", "InterpreterCoroutineEntry");

  StoreLocal(RBX, 1);
  Drop(1);

  Dispatch(kCoroutineChangeLength);
}
```

Чуть дальше я буду рассказывать о своих ощущениях на этом этапе моего пути, но когда я увидел, что есть Dart, в котором есть то, что  мне нужно и он отменен, признаюсь честно, мне стало очень грустно. 
Дело даже не в том, что я не смогу сократить объем своей работы (бесполезно пытаться ориентироваться на Dartino, когда работаешь с DartVM). 
Дело в том, что оказывается 10 лет назад была легковесная, маленькая реализация Dart, которую просто забросили. Расстраивает сам факт того, что столько работы осталось без применения, без развития. 

# Show me your motivation

Как и обещал, фиксирую свое состояние на этом этапе разработки. 
Я был расстроен из-за Dartino, но моя уверенность и мой настрой не потерялись. 
Я нашел много красивых реализаций корутин, которые я могу использовать для разработки. 
Кстати, команде Tarantool огромное спасибо за OpenSource, это правда нужно миру, не забрасывайте его, пожалуйста.
Так что, после моего небольшой анализа и поисков примеров для реализации, мой уровень решимости все еще... 90%, потому что Dartino правда расстроил.
Нет, серьезно, склонируйте себе репозиторий, посмотрите на код, почитайте, может быть среди вас найдется тот, кто сможет возродить этот проект.

# Пошла жара

Следующая статья будет максимально технической. Я собираюсь рассказать о том, что из себя представляет реализация корутин на Dart.
Какие аспекты DartVM пришлось затронуть. Какие особенности Dart мне мешали, а какие помогали на моем пути. 
Также, по традиции, будет фиксация моего состояния к моменту того, как я смог сделать первый рабочий прототип.
Тем, кто хочет посмотреть на жесткий Dart Assembler Generator - тыкайте сюда (здесь будет ссылка на следующую часть).

Спасибо за внимание !