---
title: "О времени, сложности и мотивации: знакомство"
description: Мои приключения в мире Dart VM. Часть 1. 
date: "2025-04-09"
label: Article
tags: IT, Dart, Dart VM, ASM, Coroutines, Habr
time: 10 min
---
> [!NOTE]
>Приветствую вас, читатели. 
>Подозреваю, что вы из мира программирования. Приглашаю вас присоединиться к увлекательному рассказу о том, как один энтузиаст решил доработать свой любимый язык.
>Я собираюсь рассказать об увлекательном опыте внесения существенных изменений в очень сложную архитектуру кода.
>Будет несколько статей, это первая.
>Здесь мы не будем глубоко изучать технику, поэтому я заранее хочу предупредить о наличии в тексте определенных терминов, значение которых будет раскрыто в следующих частях.
> Для тех, кто хочет весь список сразу, держите:
>* [Часть 1: О времени, сложности и мотивации: знакомство](/blog/ru/dart-1)
>* [Часть 2: О времени, сложности и мотивации: такие разные функции в Dart](/blog/ru/dart-2)
>* [Часть 3: О времени, сложности и мотивации: история поражения](/blog/ru/dart-3)
>* [Часть 4: О времени, сложности и мотивации: история победы](/blog/ru/dart-4)
>* [Часть 5: О времени, сложности и мотивации: финал](/blog/ru/dart-5)

# Об авторе

Позвольте представиться: я Антон, программист-даос и ценитель чайных церемоний.  

В то время как многие коллеги превращают кофе в строчки кода, я нахожу вдохновение в хорошем китайском чае.  
Десять лет я совмещаю два этих искусства — завариваю чай и пишу код. Чай бывает разный, и код тоже.  

Начинал с классического Java Backend, затем добавил Groovy и Kotlin, а потом пришло время моего первого фреймворка (о нём — позже).  
После JVM-мира я погрузился в [Эльбрус](https://habr.com/ru/companies/rostelecom/articles/562858/) и увлекательное портирование ПО на разных языках.  

Но сегодня хочу рассказать о самом интересном (хотя и не самом свежем) опыте — работе с [Dart](https://dart.dev/).  
Сейчас я Platform Engineer с уклоном в Go, но Dart заслуживает отдельной истории.

# А зачем

В технических статьях редко встретишь объяснение, зачем они вообще написаны. Мне же хочется быть честным с читателем с первых строк.  

Дело в том, что за 10 лет программирования у меня не было периода, когда бы я *не* писал код после работы или учёбы. Накопилось немало интересного материала — того, что действительно достойно публикации.  

Но каждый раз, задаваясь вопросом *«Зачем?»*, я не находил убедительного ответа.  

Сейчас он появился: это попытка **достучаться**.  

— Достучаться до тех, кто верит, что OpenSource автоматически означает массовую доработку кода. Я в это **не** верю.  
— Достучаться до тех, кто не верит, что может изменить что-то важное — даже сам язык. А вот в это я верю **крепко**.  
— Достучаться до уставших. Любой бы устал: текущее состояние гибкости и поддерживаемости кода оставляет желать лучшего.  
— Достучаться до Dart-сообщества: ребята, пора вытаскивать Dart из фронтенд-ниши. Взгляните, на что он способен! Небольшое усилие — и он завоюет бэкенд.  
— Достучаться до команды Dart (вдруг кто-то прочитает):  

![dart-1-image-1](/dart-1-image-2.png)  

*Обожаю эту картинку — регулярно напоминаю себе её смысл.*  

И ещё — **повод**. Один мой друг сказал: *«Статья — это тоже коммуникация»*. Сейчас я сознательно в изоляции, чтобы подтолкнуть себя к более масштабному общению, чем переписка в чатах.

# О чем пойдет разговор
Итак, начинается цикл из пяти статей о моем эксперименте с Dart Language и Dart VM.  

Предыстория такова: обычный разработчик захотел добавить в язык сложную фичу.  

Давайте представим: вам нравится язык, но чего-то в нем не хватает. Не магическую кнопку "сделай за меня", а что-то технически значимое — будь то новая библиотека, синтаксический сахар, ключевое слово или даже механизм исполнения кода.  

В моем случае это были корутины в Dart. И мне удалось [реализовать](https://github.com/antonbashir/dart-fibers) их — с кучей ограничений, но все же.  

Наверняка подумали: "Ну вот, еще одна история успеха про самодельный велосипед". Но суть не в этом. Я хочу рассказать не столько о том, *что* и *как* сделано, а о том, *что я чувствовал* на разных этапах — как разработчик и просто человек.  

Будет много технических деталей, конечно, но фокус — на состояниях, через которые проходил.  

Прежде чем начать, спросите себя: "А стоит ли мне это читать?" Помогу с ответом.  

**Кому может быть интересно:**  
* Тем, кто хочет добавить фичу в язык  
* Тем, кто видит Dart не только как Flutter-рантайм  
* Любителям разбираться в компиляторах и внутренностях языков  
* Выгорающим разработчикам (может, отвлечетесь?)  
* Студентам в поисках темы для диплома  

**Кому, возможно, не зайдет:**  
* Тем, кто не интересуется устройством языков  
* Flutter-разработчикам, которым не нужны глубины Dart (про Flutter — ни слова)  

Теперь, когда все формальности соблюдены, налью пуэр и, если позволите, начну.

# В начале было слово

И имя ему — [ART](https://github.com/art-community/art-java). Так я окрестил свой первый фреймворк для Java/Kotlin.  

**Что умел этот зверь:**  
* Элегантная обработка HTTP/RSocket трафика  
* Работа с Tarantool  
* Интеграция (ранее была) с реляционными БД  
* Взаимодействие (было) с Kafka  
* Динамическое применение изменений конфигураций на лету  

А еще — компиляция в нативный бинарник через [GraalVM](https://www.graalvm.org/).  

Я задумал его как инструмент для чистой и гибкой разработки сервисов на Java/Kotlin. Без рефлексии, без модификаций байт-кода, без лишней инверсии контроля, без аннотаций.  

Простота без потери мощности — чтобы разработчик мог легко создавать production-решения. Да, очередной велосипед, ничего сверхъестественного.  

Но потом я понял: сложности есть не только в бэкенде. Фронтенд и инфраструктура тоже страдают.  

Так появились [art-platform](https://github.com/art-community/art-platform) и [art-react](https://github.com/art-community/art-react) — ещё два велосипеда в коллекцию.  

Идея была проста: единый инструментарий для всего цикла разработки — от написания кода до деплоя.

# Почему корутины ?

Работа есть работа — велосипеды подождут. Параллельно с ночными экспериментами приходилось заниматься и реальными проектами, где я столкнулся с любопытными технологиями.  

Среди них были Tarantool, Golang, Koishi, node-fibers и ucontext — все они так или иначе связаны с элегантной абстракцией под названием **корутины**.  

Признаюсь честно: когда я наконец разобрался, как они работают, это было озарение. С тех пор их красота и эффективность не выходят у меня из головы.  

Если хотите погрузиться в тему, вот хорошие отправные точки:  
* [Общее объяснение](https://habr.com/ru/articles/850970/)  
* [Корутины в Kotlin](https://kotlinlang.org/docs/coroutines-overview.html)  
* [Реализация в Tarantool](https://www.tarantool.io/en/dev/core/fiber/)  

Это одна из тех концепций, которые меняют взгляд на асинхронный код.

# Почему Dart ?
На определённом этапе разработки ART я чётко сформулировал технические требования к языку для реализации своих идей — и Java, увы, перестала им соответствовать.  

Именно тогда я случайно открыл для себя Dart — и обнаружил, что он идеально ложится в мои критерии. Так закончилась моя Java-эпоха и начался Dart-путь.  

**Почему именно Dart?** Мне нужен был язык, который:  
* Работает везде: нативные десктопы (Linux/Windows/macOS), мобильные платформы (iOS/Android), веб и бэкенд  
* Обладает выразительным синтаксисом для создания простых, но эффективных языковых конструкций  
* Одновременно компилируется в компактный бинарник без зависимостей *и* позволяет горячую перезагрузку кода при разработке  
* Даёт низкоуровневый доступ к нативным технологиям (C/C++/Rust) для преодоления ограничений рантайма  
* Обеспечивает автоматическое управление памятью (в любой форме)  

Рассматривал альтернативы: Go, Rust, Kotlin, Nim, Crystal, V, C/C++. Но выбор пал на Dart.  

История мучительного выбора с таблицами сравнения и метаниями достойна отдельного поста — но здесь просто примем как факт: Вселенная подкинула мне Dart, и я не стал спорить.

# Новый путь
Прежде чем погружаться в очередной фреймворк, я решил расширить экосистему Dart, создав несколько ключевых модулей:

* **[IOUring модуль](https://github.com/antonbashir/dart-iouring-transport)** — даёт доступ к мощному Linux-механизму [IOUring](https://unixism.net/loti/what_is_io_uring.html)  
* **[Tarantool модуль](https://github.com/antonbashir/dart-tarantool-storage)** — позволяет писать на Dart вместо Lua для [Tarantool](https://www.tarantool.io/en/)  
* **[RSocket модуль](https://github.com/antonbashir/dart-reactive-transport)** — минимально достаточная реализация [RSocket](https://rsocket.io/) протокола  

После этого относительно успешного опыта велосипедостроения я подошёл к моменту, где началась настоящая магия — история "романтических" отношений между Dart и корутинами.  

Мне отчаянно понадобились корутины. И я решил их реализовать.  

Здесь начинается не столько техническая история, сколько история трансформации — и как разработчика, и просто как человека.  

Важно: я хочу говорить не о ассемблерных инструкциях и системных вызовах, а о тех вызовах, с которыми сталкивается каждый разработчик в процессе создания чего-то нового. 

О том, что остаётся за кадром большинства технических статей.

# Начальное состояние
Осознав творческий потенциал Dart, я испытывал настоящий восторг. Этот язык открывал потрясающие возможности:  

- Кроссплатформенный UI через Flutter  
- Нативная совместимость через FFI  
- Векторизация вычислений через SIMD  
- Графика через шейдеры  
- Метапрограммирование через кодогенерацию  

Я был полон амбиций и готовности погрузиться в совершенно новую для меня область — реализацию корутин.  

Состояние было противоречивым: с одной стороны — вдохновение от безграничных возможностей, с другой — страх перед внедрением новой модели исполнения кода. Но творческий азарт перевесил все сомнения. 

# Ну что, погнали ?

Решимость на максимуме, пуэр заварен, IDE запущена — пора разбираться в основах.  

**Но сначала вопрос:** что не так с родными [async/await](https://dart.dev/libraries/async/async-await) и `Future` в Dart? Ведь они и так дают асинхронность.  

Присмотримся к их работе — интуиция подсказывает, что реализация корутин будет строиться на схожих принципах, но с критическими отличиями.  

1. **Создают цепочки обещаний** — каждый `await` это точка разрыва потока исполнения  
2. **Требуют явной пометки `async`** — заранее "заражают" всю цепочку вызовов  
3. **Работают через механизм событийной очереди** — что иногда даёт неочевидные накладные расходы  
4. **Не имеют состояния между вызовами** — каждый `await` это полноценный вход/выход из контекста  

Именно эти ограничения и заставляют задуматься о более гибкой абстракции — корутинах, которые:  
- Сохраняют состояние между приостановками  
- Позволяют тоньше управлять переключениями контекста  
- Могут работать без привязки к событийному циклу  

Но чтобы понять, *как* это сделать в Dart — сначала нужно разобрать, как устроены существующие механизмы асинхронности.

Итак, с чем мы работаем ?
* Thread 
* Isolate
* Future
* Coroutine & Fiber

Я постараюсь дать мои собственные определения этим понятиям с учетом работы с Dart.

## Thread

Поток, нить - так его называют. Концепция потока присутствует во многих языках, с которыми я работал.

> [!NOTE]
> А вот в Dart её нет. Точнее, её нет для Dart разработчика, но в Dart VM с потоками все хорошо.

Всегда эта концепция представляет собой что-то, что нужно использовать для параллельного выполнения кода.

Я раскрываю эту концепцию таким образом: поток - это структура, содержащая стек, хранилище, атрибуты, состояние и что-то еще в зависимости от реализации.

Управляет этой структурой ваш runtime - это может быть виртуальная машина или операционная система.

Идея этой структуры - организовать управление инструкциями выполнения кода в соответствии с определенными требованиями.

Пример требований - утилизировать все доступные нам ядра процессора.

Для этого мы можем с помощью потоков "дать указание" планировщику нашего runtime о том, что вот этот код нужно выполнять параллельно (на разных ядрах).

## Isolate

Изолированный (изолировать). Относительно новое понятие. Впервые я встретил его в Dart.

Вообще концепция "изолят", как я их называю, очень даже простая. 

Изолят - это коробка, в которую положили код, динамическую память (простыми словами "кучу"), какие-то атрибуты и отправили это все "плыть" по потоку.

Смысл существования изолят вот в чем - у потоков есть проблема, с которой пытаются бороться разными способами. 

Код двух потоков может изменять общие данные - состояние гонки потока. 

И чтобы этих общих данных не было - придумали изоляты.

Дополнительно, разграничение памяти по изолятам может упростить сборку мусора: просто сегментирует память и уменьшает объем сборки в рамках одного изолята.

Изоляты и потоки связаны: когда Dart хочет выполнить код, он берет этот "код" в изоляте и назначает поток, который будет выполнять код.

Вообще хорошо написал про эту архитектуру [Вячеслав Егоров](https://habr.com/ru/users/mraleph): [оригинал](https://mrale.ph/dartvm/) и [перевод](https://habr.com/ru/articles/848166/).

Кстати, если ты это читаешь, загляни [сюда](https://github.com/antonbashir/dart), может быть все же решите добавить корутины в Dart :)

## Future

В Dart есть 2 типа функций (вообще 4, но давайте остановимся на двух) - синхронные и асинхронные.

С синхронными все понятно. Обычная функция, есть результат, имя, аргументы: бери и вызывай. 

```dart
void main() {
  print("before start");
  final result = child(0);
  print("child result: $result");
  print("after start");
}

int child(int argument) {
  print("child: entry($argument)");
  return 0;
}
```

```
before start
child: entry(0)
child result: 0
after start
```

С асинхронными все весело. Сейчас покажу.

```dart
Future<void> main() async {
  print("before start");
  final result = child(0);
  print("child result: $result");
  final resultWhenReady = await result;
  print("child result when ready: $resultWhenReady");
  print("after start");
}

Future<int> child(int argument) async {
  await otherChild();
  print("child: entry($argument)");
  return 0;
}

Future<void> otherChild() async {
  print("other child");
}
```

```
before start
other child
child result: Instance of 'Future<int>'
child: entry(0)
child result when ready: 0
after start
```

Вот смотрите. `main` вызвал `child`. `child` вызвал `otherChild`. 

Получили вывод: `before start -> other child -> child result -> child: entry -> child result when ready -> after start`.

Мы сначала получили вывод из `other child`, а потом мы получили `child result` вместо того, чтобы получить `child: entry`.

В этом и есть смысл асинхронных функций: мы не "ждем" выполнения асинхронной функции, мы просто выполняем наш код дальше. 
Чтобы отслеживать состояние асинхронной функции и получить результат из нее, мы используем объект `Future`.

При этом важно отметить: в рамках одного изолята в Dart две асинхронные функции никогда не выполняются параллельно.
В один момент времени работает только один поток, который выполняет какую-то функцию (синхронную или асинхронную).

## Coroutine & Fiber

Моя прелесть. Здесь начнется самое веселое. Взгляните на это и попытайтесь осознать, что здесь происходит.

```dart
var commonState = "";

void main() {
  print("before start");
  Fiber.launch(mainEntry);
  print("after start");
}

void mainEntry() {
  print("main: entry");
  commonState += "main -> ";
  Fiber.spawn(childEntry);
  commonState += "main -> ";
  print("main: after child transfer");
  Fiber.reschedule();
  print(commonState);
}

void childEntry() {
  print("child: entry");
  commonState += "child -> ";
  Fiber.reschedule();
  commonState += "child";
}
```

```
before start
main: entry
child: entry
main: after child transfer
child: after main transfer
main -> child -> main -> child
after start
```

Итак. Мы сделали `Fiber.launch`, куда передали ссылку на функцию `mainEntry`. Здесь все легко и понятно.

Где-то внутри `Fiber.launch` мы запустили наш `mainEntry` (вывод `main: entry`). 

Далее мы запустили `Fiber.spawn`, куда передали ссылку на функцию `childEntry`. Ну тоже не очень сложно.

Там у нас как-то запустился наш `childEntry` (вывод child: entry).

Потом вызывается какой-то странный `Fiber.reschedule()` и мы видим вывод: `main: after child transfer`.

Внимание вопрос, какой такой магией мы из `childEntry()` вдруг снова оказались в `mainEntry()`, да еще и где-то в середине функции ?

Но самое интересно у нас дальше. Мы снова делаем `Fiber.reschedule()` и оказываемся в `childEntry()` O_o. 

Ответ - вот, что такое корутины. Корутина - это структура, которая позволяет нам управлять выполнением нашего кода так, как мы хотим того сами.

Я бы сказал так: поток является корутиной для того `runtime` (ОС или VM), который его выполняет. Еще корутины называют "зеленые потоки".

Ну а Ffiber ? Fiber это high-level абстракция, которая дает удобный API для управления корутинами. 

# Заглядываем под капот: Future

> [!NOTE]
> Вообще текущая реализация async в Dart (как мне кажется) реализована одним человеком - [Александр Марков](https://github.com/alexmarkov). 
> Александр, если ты это читаешь, ну добавь корутины, ну позязя :)

С чего бы начать...

Так как функционал там достаточно объемный, я бы хотел сфокусировать внимание на одном сценарии:

```dart
Future<void> main async {
  final myFuture = myFunction();
  await myFuture;
}

Future<String> myFunction() async { return "Hello, World!"; }
```

Схема выполнения кода с учетом `async-await`: 
1. Вызвалась фукнция `main()` -> 
2. Вызвали функцию `myFunction()` ->
3. Неявно создали объект `Future` -> 
4. Функция `myFunction()` завершилась -> 
5. "дождались" `myFuture` и взяли оттуда значение

И первое, что бросается в глаза - класс `Future`. Пожалуй, с чего мы и начнем.

Вообще, `Future` - это очень удобный, публичный, user-oriented класс.

Все методы прекрасно прокомментированы, да и по их названию можно понять, за что они отвечают.

Идея класса в том, чтобы предоставить разработчику необходимый набор операций над асинхронным выполнением/вычислением. 

Мы можем выстроить цепочку последовательных преобразований с помощью `then`, указать `callback` по завершению future `whenComplete`, обработать ошибки с помощью `catchError`. 

Я бы не хотел долго останавливаться на этом классе, потому что в первую очередь интересны не методы класса, а конструкция `await myFuture;`, которая позволяет дождаться результата `Future`.

Когда-нибудь задумывались, что вообще скрывается за ключевым словом `await` ?

Я вам сейчас расскажу, даже покажу. Вот оно:

```dart
@pragma("vm:entry-point", "call")
@pragma("vm:invisible")
Object? _await(Object? object) {
  if (_thenCallback == null) {
    _createAsyncCallbacks();
  }
  if (object is _Future) {
    if (object._isComplete) {
      _awaitCompletedFuture(object);
    } else {
      object._thenAwait<dynamic>(
          unsafeCast<dynamic Function(dynamic)>(_thenCallback),
          unsafeCast<dynamic Function(Object, StackTrace)>(_errorCallback));
    }
  } else if (object is! Future) {
    _awaitNotFuture(object);
  } else {
    _awaitUserDefinedFuture(object);
  }
  return _functionData;
}
```

Эта функция находится в классе `_SuspendState` и ее достаточно для реализации ключевого слова `await`. Поверили ? Зря, зря... 

К сожалению, между `await` и вызовом `_SuspendState._await` выполняется определенная магия, о которой пойдет разговор ниже.

Сейчас давайте немного замедлимся здесь и посмотрим, что происходит внутри `_SuspendState`, за что он отвечает и какая связь с `Future`.

Итак, в нашем случае нас интересуют следующие участки кода.

```dart
object._thenAwait<dynamic>(
    unsafeCast<dynamic Function(dynamic)>(_thenCallback),
    unsafeCast<dynamic Function(Object, StackTrace)>(_errorCallback));
```

и

```dart
_awaitCompletedFuture(object);
```

`_thenAwait` это функция у `_Future`. Вкратце, данная функция добавляет новый `_FutureListener` в наш Future.
Каждый `_FutureListener` это своего рода `callback`, который нужно вызвать в момент завершения Future. 
Мы можем регистрировать свои `_FutureListener` через `Future.then`. 

В случае `_SuspendState` будет вызван `_thenCallback`, который в свою очередь вызовет следующую функцию

```dart
thenCallback(value) {
  suspendState._resume(value, null, null);
}
```

`_awaitCompletedFuture` создает микротаску, которая должна вызвать `thenCallback`.

Краткая сводка о микротасках: если код Dart по каким-то причинам не выполняется, то выполняется код Dart VM (C++ часть). 

В коде Dart VM есть очередь (вообще их [несколько](https://habr.com/ru/articles/754194/)) событий и механизмы ожидания событий из этой очереди.

Микротаски - это события/задачи, которые выставляются в начало очереди задач и будут выполнены тогда, когда Dart VM освободится от выполнения Dart кода и проверит состояние очереди.

Чем тяжелее код, тем чернее пуэр... И тут мы подходим к самым увлекательным аспектам реализации `async-await` механики в Dart VM. 

Лучше всего реализация описана в [технической документации](https://github.com/dart-lang/sdk/blob/main/runtime/docs/async.md).

Я же постараюсь кратко задекларировать ключевые моменты для формирования общей картины понимания.

Забегая вперед следующей статьи, стоит сказать о таком функционале Dart VM как заглушка. 
Заглушка - это архитектурно зависимый код на языке ассемблера, который генерируется с помощью C++ кода Dart VM. 
Вот так выглядит простейшая заглушка:
```c++
void StubCodeCompiler::GenerateInitStaticFieldStub() {
  __ EnterStubFrame();
  __ PushObject(NullObject());  // Make room for result.
  __ PushRegister(InitStaticFieldABI::kFieldReg);
  __ CallRuntime(kInitStaticFieldRuntimeEntry, /*argument_count=*/1);
  __ Drop(1);
  __ PopRegister(InitStaticFieldABI::kResultReg);
  __ LeaveStubFrame();
  __ Ret();
}
```

Что здесь происходит ? Честно говоря, будучи Java/Dart/Go разработчиком, мне было не очень легко в этом разобраться. Но сложно - не значит невозможно.

Итак, давайте разберем эту простейшую заглушку:
1. `EnterStubFrame()` - сохраняет текущий указатель на фрейм (регистр `RBP`) на стек и перемещает текущий указатель на стек (регистр `RSP`) в регистр `RBP`.
2. `PushObject(NullObject())` - подготовка регистра для получения результата вызова последующей `Runtime` функции
3. `PushRegister(InitStaticFieldABI::kFieldReg)` - передаем регистр, в котором (судя по названию) находится поле, которое нужно инициализировать
4. `CallRuntime(kInitStaticFieldRuntimeEntry, /*argument_count=*/1)` - здесь мы вызываем `runtime` функцию, эта функция реализована на C++ и является частью кода Dart VM
5. `Drop(1)` - двигаем указатель на стек, чтобы добраться до результата
6. `PopRegister(InitStaticFieldABI::kResultReg)` - вытаскиваем результат и восстанавливаем баланс стека
7. `LeaveStubFrame()` - достаем указатель на стек из регистра `RBP` и вытаскиваем указатель на фрейм со стека
8. `Ret()` - возвращаемся из функции

Да, это была простейшая заглушка. А теперь попробуйте представить, как выглядят сложные.

Но вернемся к `async-await`. 

Итак, для реализации механизма `async-await` у нас используются следующие заглушки:
1. `GenerateAwaitStub`
2. `GenerateResumeStub`
2. `GenerateReturnAsyncStub`

`AwaitStub`, она же `SuspendStub` генерируется в месте вызова `await` инструкции. 
Эта заглушка отвечает за сохранение текущего контекста (фрейма) функции в определенное место (`_SuspendState`) и вызов асинхронной функции (в нашем случае вызов `myFunction`).

Логика примерно следующая: 
1. Создали `_SuspendState`, если надо
2. Подготовили стек и сохранили текущий фрейм в память
3. Вызвали асинхронную функцию
4. Удалили текущий фрейм функции
5. "Выпрыгнули" из текущей функции в функцию выше, в нашем случае мы "прыгнем" в С++ код Dart VM, который вызывает `main()` функцию

`ResumeStub` представляет реализацию функции `_SuspendState._resume` и отвечает за следующую логику:
1. Взять фрейм стека функции, которую нужно возобновить (она в данный момент "ждет" на `await`)
2. Восстановить стек, используя сохраненный фрейм стека той функции
3. Выполнить `jump` в точку инструкции, из которой была вызвана async функцию (то есть выполнение кода продолжится после этой точки)

`ReturnAsyncStub` работает достаточно просто в случае нашего примера: вызываем `_SuspendState._returnAsync`.

Итого. Наш путь вызова асинхронной функции выглядит следующим образом: 
* создали `_SuspendState` -> 
* сохранили текущий фрейм стека -> 
* вызвали функцию -> 
* завершили future через `_returnAsync` ->
* Dart VM выполнил микротаску, которая вызвала `thenCallback`, который вызвал `_resume` -> 
* "Прыгнули" в место вызова функции с восстановлением фрейма

# Заглядываем под капот: Coroutine

Не хочется пока что раскрывать секреты моих корутин, поэтому я вам покажу корутины из замечательной базы данных - [Tarantool](https://www.tarantool.io/en/).

Детальный разбор моих корутин будет в следующих статьях.

Fiber - основное понятие, с которым работает разработчик в Tarantool.

Fiber - это абстракция над корутиной. Fiber можно усыплять, пробуждать, можно `yield`-ить - выполнять смену одного (текущего) Fiber на любой Fiber, который готов к выполнению. 

За выполнение Fiber отвечает планировщик - Fiber Scheduler.

Давайте здесь рассмотрим два ключевых аспекта реализации корутин в Tarantool: 
1. Как работает смена контекста ?
2. Что делать, если никакой Fiber не готов к выполнению ?

Вот так выглядит реализация и сигнатура функции смены контексты корутины для Linux x64 в Tarantool:

```c
void coro_transfer (coro_context *prev, coro_context *next) {
  pushq %rbp
  pushq %rbx
  pushq %r12
  pushq %r13
  pushq %r14
  pushq %r15
  movq %rsp, (%rdi)
  movq (%rsi), %rsp
  popq %r15
  popq %r14
  popq %r13
  popq %r12
  popq %rbx
  popq %rbp
  popq %rcx
  jmpq *%rcx
}
```

Вкратце, что здесь происходит:
1. Мы передаем на вход контекст (стек) старой (в случае с Tarantool Fiber имеется в виду текущей корутины) и новой (следующей) корутины
2. Сохраняем [callee-saved](https://www.uclibc.org/docs/psABI-x86_64.pdf) регистры на стек
3. Двигаем текущий стек в контекст (сохраняем в память) старой корутины
4. Достаем стек из новой корутины
5. Восстанавливаем основные регистры со стека
6. "Прыгаем" в указатель на инструкцию (`%rcx`) (следующая инструкция после вызова `coro_transfer`)

По сути `coro_transfer` - это наш "попрыгун" между корутинами. Все операции Tarantool Fiber, в которых нужно сменить корутину, выполняются через эту функцию.

Что касательно второго вопроса: это реализуется через связку `coro_transfer` и `Event Loop`. 

Про реализацию разных `Event Loop` можно почитать, например, [тут](https://libev.schmorp.narkive.com/hKCGdLbP/and-ent), ну а в Tarantool используется [libev](https://github.com/enki/libev) библиотечка.

Рассмотрим алгоритм функции [sleep](https://www.tarantool.io/en/doc/latest/reference/reference_lua/fiber/#lua-function.fiber.sleep):
1. Регистрируем таймер с помощью libev
2. Привязываем таймер к функции, которая должна будет "разбудить" наш Fiber
3. Выполняем `yield`, он же - смена контекста на нашего вызывателя
4. Если мы сменили контекст на планировщика, и ему некого планировать, он обратится к libev
5. Когда libev ответит, что событие таймера сработало, вызовется наша функция, которая скажет планировщику - "у тебя появился готовый к работе Fiber"

Практически все fiber-related операции в Tarantool выполняются через связку libev и [libcoro](https://github.com/semistrict/libcoro)

Есть еще один прекрасный пример реализации корутин, кроссплатформенный, даже Эльбрус поддерживает. Лежит он вот [тут](https://github.com/taisei-project/koishi)

Собственно, в своей работе я и решил опираться на эти замечательные примеры. Во всяком случае я планировал так сделать. 

Получилось не очень :) 

# И зачем это все ? 

Серьезно, в чем смысл ? Реализация у async выглядит вполне себе достойной. 

Не скажу, что я жестко тестировал ее с точки зрения производительности, но те редкие бенчи, которые я делал, мне были ок.

Суть тут не в производительности. Суть в гибкости и функциональности. 

У меня возник приблизительно следующий список требований к функционалу асинхронного управления:
* я не хочу использовать дополнительные объекты [Completer](https://api.flutter.dev/flutter/dart-async/Completer-class.html) для фиксации suspend/resume точек
* я хочу бесшовную интеграцию с [FFI](https://dart.dev/interop/c-interop): то есть, когда из native уровня сработало событие, я хочу, чтобы корутина на Dart уровне была тут же разбужена без накладных расходов
* меня не очень устроил объем вспомогательного Dart кода внутри Future: кажется, это можно сделать попроще
* абсолютно не нравится, что код превращается из единой модели в две, среди которых нет удобных переходов: `sync` функции и `async` легко не [свяжешь](https://github.com/dart-lang/sdk/issues/39390)
* шило в... короче, велосипедная тяга - стало интересно это реализовать :) 

# Немного про Dartino 

Перед тем как пойти делать свою реализацию, мне стало интересно: может быть уже что-то имеется. И да, кое-что есть. 

Встречайте, [Dartino!](https://github.com/dart-archive/sdk)

Dartino это реализация Dart VM под embedded устройства. Она оказалась [заброшена](https://groups.google.com/g/dartino-discuss/c/U3fzZjoOdKg/m/0CB8ON6RCAAJ).

Но посмотрите, что я смог в ней найти:

```c++
void InterpreterGeneratorX64::DoCoroutineChange() {
  LoadLiteralNull(RAX);

  LoadLocal(RBX, 0);  // Load argument.
  LoadLocal(RSI, 1);  // Load coroutine.

  StoreLocal(RAX, 0);
  StoreLocal(RAX, 1);

  Label resume;
  SaveState(&resume);
  LoadProcess(RDI);
  // RSI already loaded with coroutine.
  __ call("HandleCoroutineChange");
  RestoreState();

  __ Bind(&resume);
  __ Bind("", "InterpreterCoroutineEntry");

  StoreLocal(RBX, 1);
  Drop(1);

  Dispatch(kCoroutineChangeLength);
}
```

Да, это Dart корутины.

Чуть дальше я буду рассказывать о своих ощущениях на этом этапе моего пути, но, когда я увидел, что есть версия Dart, в котором есть то, что мне нужно и я не могу её использовать, мне стало грустно.

Дело даже не в том, что я не смогу сократить объем своей работы, так как бесполезно пытаться ориентироваться на Dartino, когда работаешь с Dart VM. 

Дело в том, что оказывается 10 лет назад была легковесная, маленькая реализация Dart, которую просто забросили. Расстраивает сам факт того, что столько работы осталось без применения, без развития. 

# Что с мотивацией ?

Как и обещал, фиксирую свое состояние на этом этапе разработки.
Я был расстроен из-за Dartino, но моя уверенность и мой настрой не потерялись.
Я нашел много красивых реализаций корутин, которые я могу использовать для разработки.

Кстати, команде Tarantool огромное спасибо за OpenSource! Это правда нужно миру. Пожалуйста, развивайте его.

После моего небольшого анализа и поисков примеров для реализации, мой уровень решимости - 90%, потому что Dartino правда расстроил.

Нет, серьезно, склонируйте себе репозиторий, посмотрите на код, почитайте, может быть среди вас найдется тот, кто сможет возродить этот проект.

# Пошла жара

Следующая статья будет максимально технической. Я собираюсь рассказать о том, что из себя представляет реализация корутин на Dart.
Какие аспекты Dart VM пришлось затронуть. Какие особенности Dart мне мешали, а какие помогали на моем пути. 

Разумеется, будет фиксация моего состояния к моменту создания первого рабочего прототипа.

Приглашаю посмотреть на жесткий технический BDSM ( Breaking Dart Stub Manipulation ). Тыкайте [сюда](/blog/ru/dart-3).

Спасибо за внимание !